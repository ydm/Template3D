#include "shaders.hpp"
#include <sstream>
#include "utils/file.hpp"


namespace shaders
{
    
    
    // ========================
    // Shader
    // ========================

    Shader::Shader(const GLenum type, const std::string& source)
    : type_(type)
    , source_(source)
    , id_(0)
    , next_(nullptr)
    {
    }


    Shader::~Shader()
    {
    }

    
    bool Shader::create()
    {
        GLenum err = GL_NO_ERROR;

        // Crerate shader object.
        id_ = glCreateShader(type_);
        if (id_ == 0)
        {
            std::cerr << "[E] Shader::create: glCreateShader: Error while creating shader object." << std::endl;
            return false;
        }
        
        err = glGetError();
        if (err != GL_NO_ERROR)
        {
            switch (err)
            {
            case GL_INVALID_ENUM: std::cerr << "[E] Shader::create: glCreateShader: `type` is not an accepted value." << std::endl; break;
            }
            return false;
        }

        // Assign source.
        std::string& src = utils::file::read(source_);
        if (src.length() == 0)
        {
            std::cerr << "[E] Shader::create: Error while reading file '" << source_ << "'" << std::endl;
            free();
            return false;
        }
        const char *ary[1] = { src.c_str() };
        glShaderSource(id_, 1, ary, NULL);

        // Check for errors.
        err = glGetError();
        if (err != GL_NO_ERROR)
        {
            switch (err)
            {
            case GL_INVALID_VALUE: std::cerr << "[E] Shader::create: glShaderSource: `shader` is not a value generated by OpenGL" << std::endl; break;
            case GL_INVALID_OPERATION: std::cerr << "[E] Shader::create: glShaderSource: `shader` is not a shader object" << std::endl; break;
            }
            free();
            return false;
        }

        // Check if shader compilation is supported.
        GLboolean supported = GL_FALSE;
        glGetBooleanv(GL_SHADER_COMPILER, &supported);
        if (supported == GL_FALSE)
        {
            std::cout << "[I] Shader::create: shader compilation is not supported." << std::endl;
            return true;
        }

        // Compile shader.
        glCompileShader(id_);

        // Check status.
        GLint status = GL_FALSE;
        glGetShaderiv(id_, GL_COMPILE_STATUS, &status);
        if (status != GL_TRUE)
        {
            free();
            return false;
        }
        return true;
    }


    bool Shader::free()
    {
        // If id_ is 0, it will be silently ignored
        if (id_ == 0)
        {
            return false;
        }
        glDeleteShader(id_);

        const GLenum err = glGetError();
        if (err != GL_NO_ERROR)
        {
            switch (err)
            {
            case GL_INVALID_VALUE: std::cerr << "[E] Shader::free: glDeleteShader: `shader` is not a value generated by OpenGL" << std::endl; break;
            }
            return false;
        }
        return true;
    }


    // ========================
    // Program
    // ========================

    Program::Program()
    : head_(nullptr)
    , tail_(nullptr)
    , id_(0)
    {
    }


    Program::~Program()
    {
    }


    bool Program::create()
    {
        id_ = glCreateProgram();
        if (id_ == 0)
        {
            std::cerr << "[E] Program::create: glCreateProgram failed" << std::endl;
            return false;
        }
        return true;
    }


    bool Program::attachShader(const GLenum type, const std::string& source)
    {
        Shader *const shader = new Shader(type, source);
        if (!shader->create())
        {
            // ydm TODO: Log error?
            delete shader;
            return false;
        }

        glAttachShader(id_, shader->id_);
        const GLenum err = glGetError();
        if (err != GL_NO_ERROR)
        {
            std::cerr << "[E] Program::attachShader: glAttachShader: ";
            switch(err)
            {
            case GL_INVALID_VALUE: std::cerr << "either program or shader is not a value generated by OpenGL"; break;
            case GL_INVALID_OPERATION: std::cerr << "program/shader is not a valid object OR shader is already attached to program"; break;
            }
            std::cerr << std::endl;

            shader->free();
            delete shader;
            return false;
        }

        if (head_ == nullptr)
        {
            head_ = tail_ = shader;
        }
        else
        {
            tail_->next_ = shader;
            tail_ = shader;
        }
        return true;
    }


    bool Program::free()
    {
        // ydm TODO: FREE SHADERS TOO!
        if (id_ == 0)
        {
            return false;
        }
        glDeleteProgram(id_);
        const GLenum err = glGetError();
        if (err != GL_NO_ERROR)
        {
            switch (err)
            {
            case GL_INVALID_VALUE: std::cerr << "[E] Program::free: program is not a value generated by OpenGL" << std::endl; break;
            }
            return false;
        }
        return true;
    }

    
    bool Program::use() const
    {
        glUseProgram(id_);
        const GLenum err = glGetError();
        if (err != GL_NO_ERROR)
        {
            std::cerr << "[E] Program::use: glUseProgram: ";
            switch (err)
            {
            case GL_INVALID_VALUE: std::cerr << "`program` is neither 0 nor a value generated by OpenGL"; break;
            case GL_INVALID_OPERATION: std::cerr << "`program` is not a program object OR could not be used OR feedback mode is active"; break;
            }
            std::cerr << std::endl;
            return false;
        }
        return true;
    }


    bool Program::link()
    {
        glLinkProgram(id_);
        const GLenum err = glGetError();
        if (err != GL_NO_ERROR)
        {
            std::cerr << "[E] Program::link: glLinkProgram: ";
            switch (err)
            {
            case GL_INVALID_VALUE: std::cerr << "`program` is not a value generated by OpenGL";
            case GL_INVALID_OPERATION: std::cerr << "`program` is not a program object OR it is the currently active program and transform feedback mode is active"; break;
            }
            std::cerr << std::endl;
            return false;
        }
        return true;
    }

        
    GLuint Program::attr(const GLchar *const name)
    {
        const GLuint a = glGetAttribLocation(id_, name);
        // ydm TODO: CHECK!
        return a;
    }


    GLuint Program::unif(const GLchar *const name)
    {
        const GLuint u = glGetUniformLocation(id_, name);
        // ydm TODO: CHECK!
        return u;
    }
}
