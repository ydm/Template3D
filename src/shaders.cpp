#include "shaders.hpp"
#include <sstream>
#include "utils/file.hpp"


namespace shaders
{
    // ========================
    // Helpers
    // ========================
    std::string infoLog(const GLuint id)
    {
        GLint len;
        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &len);

        GLchar *log = new GLchar[len + 1];
        glGetShaderInfoLog(id, len, nullptr, log);

        std::stringstream logStream;
        logStream << log;
        delete [] log;

        return logStream.str();
    }
    
    
    // ========================
    // Shader
    // ========================

    Shader::Shader(const GLenum type, const std::string& source)
    : type_(type)
    , source_(source)
    , id_(0)
    , next_(nullptr)
    {
    }


    Shader::~Shader()
    {
    }

    
    bool Shader::create()
    {
        GLenum err = GL_NO_ERROR;

        // Crerate shader object.
        id_ = glCreateShader(type_);
        if (id_ == 0)
        {
            std::cerr << "[E] Shader::create: glCreateShader: Error while creating shader object." << std::endl;
            return false;
        }
        
        err = glGetError();
        if (err != GL_NO_ERROR)
        {
            switch (err)
            {
            case GL_INVALID_ENUM: std::cerr << "[E] Shader::create: glCreateShader: `type` is not an accepted value." << std::endl; break;
            }
            return false;
        }

        // Assign source.
        std::string& src = utils::file::read(source_);
        if (src.length() == 0)
        {
            std::cerr << "[E] Shader::create: Error while reading file '" << source_ << "'." << std::endl;
            free();
            return false;
        }
        const char *ary[1] = { src.c_str() };
        glShaderSource(id_, 1, ary, NULL);

        // Check for errors.
        err = glGetError();
        if (err != GL_NO_ERROR)
        {
            switch (err)
            {
            case GL_INVALID_VALUE: std::cerr << "[E] Shader::create: glShaderSource: `shader` is not a value generated by OpenGL." << std::endl; break;
            case GL_INVALID_OPERATION: std::cerr << "[E] Shader::create: glShaderSource: `shader` is not a shader object." << std::endl; break;
            }
            free();
            return false;
        }

        // Check if shader compilation is supported.
        GLboolean supported = GL_FALSE;
        glGetBooleanv(GL_SHADER_COMPILER, &supported);
        if (supported == GL_FALSE)
        {
            std::cout << "[I] Shader::create: shader compilation is not supported." << std::endl;
            return true;
        }

        // Compile shader.
        glCompileShader(id_);

        // Check status.
        GLint status = GL_FALSE;
        glGetShaderiv(id_, GL_COMPILE_STATUS, &status);
        if (status != GL_TRUE)
        {
            std::cerr << "[E] Shader::create: '" << source_ << "' failed to compile." << std::endl;
            std::cerr << infoLog(id_) << std::endl;
            free();
            return false;
        }
        return true;
    }


    bool Shader::free()
    {
        // If id_ is 0, it will be silently ignored.
        if (id_ == 0)
        {
            return false;
        }
        
        glDeleteShader(id_);
        id_ = 0;

        const GLenum err = glGetError();
        if (err != GL_NO_ERROR)
        {
            switch (err)
            {
            case GL_INVALID_VALUE: std::cerr << "[E] Shader::free: glDeleteShader: `shader` is not a value generated by OpenGL." << std::endl; break;
            }
            return false;
        }
        return true;
    }


    // ========================
    // Program
    // ========================

    Program::Program()
    : head_(nullptr)
    , tail_(nullptr)
    , id_(0)
    {
    }


    Program::~Program()
    {
    }


    bool Program::create()
    {
        id_ = glCreateProgram();
        if (id_ == 0)
        {
            std::cerr << "[E] Program::create: glCreateProgram failed." << std::endl;
            return false;
        }
        return true;
    }


    bool Program::attachShader(const GLenum type, const std::string& source)
    {
        Shader *const shader = new Shader(type, source);
        if (!shader->create())
        {
            // ydm TODO: Log error?
            delete shader;
            return false;
        }

        glAttachShader(id_, shader->id_);
        const GLenum err = glGetError();
        if (err != GL_NO_ERROR)
        {
            switch(err)
            {
            case GL_INVALID_VALUE: std::cerr << "[E] Program::attachShader: glAttachShader: either program or shader is not a value generated by OpenGL." << std::endl; break;
            case GL_INVALID_OPERATION: std::cerr << "[E] Program::attachShader: glAttachShader: program/shader is not a valid object OR shader is already attached to program." << std::endl; break;
            }

            shader->free();
            delete shader;
            return false;
        }

        // Add to linked list
        if (head_ == nullptr)
        {
            head_ = tail_ = shader;
        }
        else
        {
            tail_->next_ = shader;
            tail_ = shader;
        }
        std::cout << "[I] Program::attachShader: '" << source << "' attached." << std::endl;
        return true;
    }


    bool Program::detachShader(const GLuint shader)
    {
        glDetachShader(id_, shader);
        const GLenum err = glGetError();
        if (err != GL_NO_ERROR)
        {
            switch (err)
            {
            case GL_INVALID_VALUE: std::cerr << "[E] Program::detachShader: either `program` or `shader` is a value that was not generated by OpenGL" << std::endl; break;
            case GL_INVALID_OPERATION: std::cerr << "[E] Program::detachShader: `program` OR `shader` is invalid object OR `shader` is not attached to `program`" << std::endl; break;
            }
            return false;
        }
        return true;
    }


    bool Program::free()
    {
        // Detach and free shaders.
        Shader *p = head_;
        while (p != nullptr)
        {
            Shader *const del = p;
            p = p->next_;

            if (detachShader(del->id_))
            {
                std::cout << "[I] Program::free: '" << del->source_ << "' detached." << std::endl;
            }
            del->free();
            delete del;
        }
        head_ = tail_ = nullptr;

        // Free program.
        if (id_ == 0)
        {
            return false;
        }

        glDeleteProgram(id_);
        id_ = 0;

        const GLenum err = glGetError();
        if (err != GL_NO_ERROR)
        {
            switch (err)
            {
            case GL_INVALID_VALUE: std::cerr << "[E] Program::free: program is not a value generated by OpenGL" << std::endl; break;
            }
            return false;
        }
        return true;
    }

    
    bool Program::use() const
    {
        glUseProgram(id_);
        const GLenum err = glGetError();
        if (err != GL_NO_ERROR)
        {
            std::cerr << "[E] Program::use: glUseProgram: ";
            switch (err)
            {
            case GL_INVALID_VALUE: std::cerr << "`program` is neither 0 nor a value generated by OpenGL"; break;
            case GL_INVALID_OPERATION: std::cerr << "`program` is not a program object OR could not be used OR feedback mode is active"; break;
            }
            std::cerr << std::endl;
            return false;
        }
        return true;
    }


    bool Program::link()
    {
        glLinkProgram(id_);
        const GLenum err = glGetError();
        if (err != GL_NO_ERROR)
        {
            std::cerr << "[E] Program::link: glLinkProgram: ";
            switch (err)
            {
            case GL_INVALID_VALUE: std::cerr << "`program` is not a value generated by OpenGL";
            case GL_INVALID_OPERATION: std::cerr << "`program` is not a program object OR it is the currently active program and transform feedback mode is active"; break;
            }
            std::cerr << std::endl;
            return false;
        }
        std::cout << "[I] Program::link: Success!" << std::endl;
        return true;
    }

        
    GLuint Program::attr(const GLchar *const name)
    {
        const GLuint a = glGetAttribLocation(id_, name);
        // ydm TODO: CHECK!
        return a;
    }


    GLuint Program::unif(const GLchar *const name)
    {
        const GLuint u = glGetUniformLocation(id_, name);
        // ydm TODO: CHECK!
        return u;
    }
}
